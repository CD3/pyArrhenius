# This file was automatically generated by libparamList version 3.2.2
                                                            #                             The main BTEC configuration file uses libparamList v3.
Dimensions                  =     2                    #  INT: ( default = NULL)      Number of dimensions in simulation. ( 1 | 2 )
SimulationType              =    "Thermal"                 #  STR: ( default = Thermal)   Simulation type to run. ( Thermal | Search | Zscan )
                                                           #                              
AxialGridType               =     0                    #  INT: ( default = NULL)      The z-axis (direction of laser propagation) grid type. ( 0 = UNIFORM | 1 = STRETCHED )
Nz                          =     3110                    #  INT: ( default = NULL)      The number of grid points along the *uniform* portion of the z-axis. If grid stretching is enabled, the actual number of points may be two or three times larger. ( > 1 )
zMin                        =     0              #[cm]  #  DBL: ( default = NULL)      The minimum coordinate of the *uniform* portion of the z-axis. If grid stretching is enabled, the actual minimum coordinate may be different.
zMax                        =     .3110             #[cm]  #  DBL: ( default = NULL)      The maximum coordinate of the *uniform* portion of the z-axis. If grid stretching is enabled, the actual maximum coordinate may be different. ( > zMin )
                                                           #                              grid stretching is used to simulate an infinite media.
                                                           #                              zMin and zMax specify the range of the uniform grid. If a stretched grid is specified, then the total number of grid
                                                           #                              points will be greater than Nz. Nz guarantees the number of points that are used to discretized the uniform portion of the
                                                           #                              grid.  If there are no surface boundaries, then both ends of the grid can be stretched, and the total number of grid
                                                           #                              points will be 3*Nz. If one boundary is a surface boundary, 2*Nz will be used. The stretched portions of the grid is discretized with
                                                           #                              the same number of as the uniform portion. Each step size in the stretched portion of the grid is the zStretchRatio
                                                           #                              times larger than the previous step (going from the uniform grid out). If zInf is given, then the range of the
                                                           #                              stretched portion of the grid will be between zMax and zInf and a stretch ratio will be calculated to achieve
                                                           #                              the desired range.  If zInf is not given, then the stretched portion of the grid will use the stretch ratio given, and
                                                           #                              the maximum z coordinate will be whatever results from the stretch Nz points. (this is generally very large)
zInf                        =     1.0215            #[cm]  #  DBL: ( default = NULL)      The location of infinity in the z-direction for an infinite media ( > zMax )
zMinBC                      =     1                    #  INT: ( default = NULL)      Boundary condition for z = zmin. The boundary can either be a sink (temperature held constant) or a surface (energy lost to environment). Three separate surface boundary conditions are implemented, and these can be combined. ( See below for boundary specification ) 
zMaxBC                      =     7                    #  INT: ( default = NULL)      Boundary condition for z = zmax. See zMinBC for description.
                                                           #                              
                                                           #                              SINK                      0
                                                           #                              CONVECTIVE                1
                                                           #                              RADIATIVE                 2
                                                           #                              CONVECTIVE + RADIATIVE    3
                                                           #                              EVAPORATIVE               4
                                                           #                              CONVECTIVE + EVAPORATIVE  5
                                                           #                              RADIATIVE + EVAPORATIVE   6
                                                           #                              ALL SURFACE               7
                                                           #                              
RadialGridType              =     0                    #  INT: ( default = NULL)      The r-axis (transverse direction) grid type. ( 0 = UNIFORM | 1 = STRETCHED )
rStretchRatio = 1.0
Nr                          =     650                   #  INT: ( default = NULL)      The number of grid points along the *uniform* portion of the r-axis. If grid stretching is enabled, the actual number of points may be two times larger. ( > 1 )
rMax                        =     .65              #[cm]  #  DBL: ( default = NULL)      The maximum coordinate of the *uniform* portion of the z-axis. If grid stretching is enabled, the actual maximum coordinate may be different. ( > 0 )
rInf                        =     1.300
rMaxBC                      =     1                    #  INT: ( default = NULL)      The boundary condition for r = rmax. The radial boundary can be either a sink (temperature held constant) or an insulator (no heat flow across boundary). ( 0 = SINK | 1 = INSULATOR )
                                                           #                              
TotalSimTime                =     $(5*float({emitters.0.pulse.duration}))             #[s]   #  DBL: ( default = NULL)      Total simulation time. This is how long the thermal simulation will be ran. Generally, this should be longer than the pulse duration.
dtMax                       =     .01              #[s]   #  DBL: ( default = NULL)      The maximum time step allowed in the stretched time step method. For the fixed time step method, this is the time step.  Currently, emitters may specify that the time step can be stretched during the simulation. This parameter specifies when stretching is stopped.
                                                           #                              
TissueBaseTemp              =     35              #[C]   #  DBL: ( default = NULL)      The simulations baseline temperature. The heat solver computes a temperature rise that is with respect to this baseline. For sink boundary conditions, the boundary temperature is held to this baseline. The initial temperature of the entire grid is also set to this baseline unless an initial conditions file is given (Note: 37 C is body temperature)
AmbientTemp                 =     35              #[C]   #  DBL: ( default = NULL)      The temperature of the environment. This temperature is used when surface boundary conditions are used present.
RelHumidity                 =     .5                    #  DBL: ( default = NULL)      The relative humidity of environment. This is used for the evaporative boundary condition. ( 0.0 - 1.0 where 1.0 = 100% )
AmbientRefIndex             =     1.0                      #  DBL: ( default = 1.0)       The refractive index of the environment, such as air. This is used in the MC photon simulation to compute refraction and reflection of photons entering the tissue surface. ( >= 1.0 )
                                                           #                              
LogDataFlag                 =     1                    # BOOL: ( default = NULL)      Global log flag for turning logging on and off. If set to 0, all logging will be turned off. If set to 1, then different data logging can be turned on and off separatly. ( 0 | 1 )
LogInterval                 =     0                        #  INT: ( default = 1)         The global default log interval. This can be overridden by specifying log intervals for each data type that is logged. Log interval is given in time steps. i.e. 10 means that 1 in every 10 time steps is logged ( >= 0 )
ThermalLogInterval          =     0                       #  INT: ( default = -1)        The thermal data log interval. If set to -1, logInterval is used. ( >= -1 )
AxialLogInterval            =     0                       #  INT: ( default = -1)        The axial thermal data log interval. If set to -1, logInterval is used. ( >= -1 )
SourceLogInterval           =     0                       #  INT: ( default = -1)        The source term data log interval. If set to -1, logInterval is used. ( >= -1 )
DamageLogInterval 	    = 	  0
                                                           #                              
                                                           #                              
Layer[0]                    =    "./layer.bk7.btec"
Layer[1]                    =    "./layer.cells.btec"
Layer[2]                    =    "./layer.water.btec"
Sensor[0]                   =    "./cell-max-temp.btec"                  #  STR: ( default = NULL)      Sensor configuration file.
InitialConditionsFlag       =     0                        # BOOL: ( default = 0)         Flag for loading initial conditions. If set to 0, no initial temperature map is loaded. If set to 1, the initial temperature distribution is loaded from initialConditionsFile. ( 0 | 1 )



#KeyValue Standard Emitter configuration (THIS MUST BE THE FIRST LINE IN THE FILE)
#BaseEmitter Configuration Keys

emitters.0.type                          =    "LinAbsEmitter"            #     STR: (See comments below; default = NONE) [] emitter type. this is the model to use
emitters.0.beam.profile.type             =    1            #     STR: (gaussian, tophat, annular, user (legacy: 1 = gaussian, 2 = tophat, 3 = annular, 4 = user defined); default = NONE) [] beam profile type

emitters.0.power                         =     1.000              #     DBL: (>= 0; default = NONE) [W] peak power of emitter (temporal)
emitters.0.pulse.profile.type            =    "square"            #     STR: (square (square pulse), gaussian (gaussian pulse), user (user defined profile); default = square) [] the temporal power profile of the exposure
emitters.0.pulse.profile.filename        =    "NONE"            #     STR: (; default = NONE) [] file containing temporal power profile of exposure
emitters.0.pulse.profile.normalize       =     1                  #     INT: (; default = 1) [] turns on/off temporal power profile normalization (if on, peak power in TemporalProfileFlag will be normalized to PeakPower)
emitters.0.wavelength                    =     532              #     DBL: (> 0; default = NONE) [nm] minimum wavelength in emitter. for non-broad band sources, this is the carrier wavelength

emitters.0.focus.type                    =     1                  #     INT: (0 = focus at infinity (collimated), 1 = finite; default = 1) [] Type of focus to use for laser emitter type
emitters.0.beam.focus.waist.position     =     .01              #     DBL: (; default = NONE) [cm] z coordinate of beam waist
emitters.0.beam.focus.divergence         =     .00              #     DBL: (; default = NONE) [cm] z coordinate of beam waist
emitters.0.beam.profile.diameter         =     .0156              #     DBL: (> 0; default = NONE) [cm] 1/e incident beam diameter.  If profileType is user defined, this value is used as a scaling factor
emitters.0.beam.profile.filename         =    "STRING"            #     STR: (; default = NONE) [] file containing beam profile as [ r  I(r)  ] pairs

emitters.0.pulse.duration                =     %duration%      #     DBL: (> 0; default = NONE) [s] duration of pulse ON time
emitters.0.pulse.period                  =     10000              #     DBL: (>= PulseDuration; default = 10000) [s] period of single pulse. pulseDuration / pulsePeriod is the duty cycle
emitters.0.pulse.start                   =     0                #     DBL: (>= 0; default = 0.0) [s] time that emitter turns on. pulse train does not start until emitter is on
emitters.0.pulse.stop                    =     2              #     DBL: (> StartTime; default = 10000) [s] time that emitter turns off

emitters.0.pulse.mode                    =     2                  #     INT: (1 = fixed, 2 = adaptive; default = 2) [] timestep type used. max timestep will be specified in the main config file
emitters.0.dtMinOn                       =     1.0E-5             #     DBL: (> 0; default = 1.0E-5) [s] minimum timestep to start with after an emitter comes on (for adaptive timestep)
emitters.0.dtMinOff                      =     1.0E-5             #     DBL: (> 0; default = 1.0E-5) [s] minimum timestep to start with when emitter is off (for adaptive timestep)
emitters.0.StretchOn                     =     1.10               #     DBL: (> 0; default = 1.10) [] time step stretch ratio to use when an emitter is on (for adaptive timestep)
emitters.0.StretchOff                    =     1.10               #     DBL: (> 0; default = 1.10) [] time step stretch ratio to use when emitter is off (for adaptive timestep)

